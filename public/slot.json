{
  "name": "slot",
  "type": "registry:lib",
  "description": "Slot component for composition",
  "files": [
    {
      "path": "share/slot.tsx",
      "type": "registry:lib",
      "content": "/**\n * Extracted directly from:\n * https://www.radix-ui.com/primitives/docs/utilities/slot\n *\n * All credit goes to the original author of this code:\n * Radix UI\n */\n\nimport { Fragment, cloneElement, isValidElement } from \"preact\";\nimport { Children, type ReactElement, type ReactNode, forwardRef } from \"preact/compat\";\nimport { composeRefs } from \"./compose_ref\";\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: ReactNode;\n}\n\nexport function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n\n  const Slot = forwardRef<any, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    const childrenArray = Children.toArray(children);\n\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (Children.count(newElement) > 1) return Children.only(null);\n          return isValidElement(newElement) ? (newElement.props as { children: React.ReactNode }).children : null;\n        }\n        return child;\n      });\n\n      return (\n        <SlotClone\n          {...slotProps}\n          ref={forwardedRef}\n        >\n          {isValidElement(newElement) ? cloneElement(newElement, undefined, newChildren) : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone\n        {...slotProps}\n        ref={forwardedRef}\n      >\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot(\"Slot\");\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nfunction createSlotClone(ownerName: string) {\n  const SlotClone = forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return cloneElement(children, props);\n    }\n\n    return Children.count(children) > 1 ? Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol(\"radix.slottable\");\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\nexport function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable(\"Slottable\");\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is ReactElement<SlottableProps & typeof Slottable> {\n  return (\n    isValidElement(child) &&\n    typeof child.type === \"function\" &&\n    \"__radixId\" in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === \"style\") {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === \"className\" || propName === \"class\") {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  //\n  Slot as Root,\n  Slot,\n  Slottable,\n};\nexport type { SlotProps };\n"
    }
  ],
  "category": "lib"
}