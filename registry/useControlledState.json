{
  "name": "useControlledState",
  "type": "registry:lib",
  "description": "Hook for controlled/uncontrolled state",
  "files": [
    {
      "path": "share/useControlledState.tsx",
      "type": "registry:lib",
      "content": "import { type Dispatch, type SetStateAction, useCallback, useEffect, useRef, useState } from \"preact/compat\";\n\ntype useControlledStateProps<T> = {\n  defaultValue?: T;\n  controlledValue?: T;\n  onChange?: (value: T) => void;\n};\n/**\n * Hook for managing controlled/uncontrolled state with enhanced functionality\n * @param defaultValue - initial value when uncontrolled\n * @param controlledValue - controlled value from parent component\n * @param onChange - callback executed when state changes\n * @returns [current state, setter function, utilities]\n */\nexport function useControlledState<T>({\n  onChange,\n  defaultValue,\n  controlledValue,\n}: useControlledStateProps<T>): [T, Dispatch<SetStateAction<T>>, { isControlled: boolean; reset: () => void }] {\n  const isControlled = controlledValue !== undefined;\n  const initialValue = useRef(defaultValue);\n\n  const [internalValue, setInternalValue] = useState<T>(() => {\n    if (isControlled) return controlledValue;\n    if (defaultValue !== undefined) return defaultValue;\n    return undefined as T;\n  });\n\n  const value = isControlled ? controlledValue : internalValue;\n\n  // Memoized setter to prevent unnecessary re-renders\n  const setValue = useCallback<Dispatch<SetStateAction<T>>>(\n    (newValue) => {\n      const resolvedValue = typeof newValue === \"function\" ? (newValue as (prevState: T) => T)(value) : newValue;\n\n      if (!isControlled) {\n        setInternalValue(resolvedValue);\n      }\n\n      // Always call onChange, even in controlled mode\n      onChange?.(resolvedValue);\n    },\n    [isControlled, onChange, value]\n  );\n\n  // Reset function to restore initial value\n  const reset = useCallback(() => {\n    const resetValue = initialValue.current;\n    if (!isControlled && resetValue !== undefined) {\n      setInternalValue(resetValue);\n    }\n    onChange?.(resetValue as T);\n  }, [isControlled, onChange]);\n\n  // Sync controlled value changes\n  useEffect(() => {\n    if (isControlled && controlledValue !== internalValue) {\n      setInternalValue(controlledValue);\n    }\n  }, [controlledValue, isControlled, internalValue]);\n\n  return [\n    value,\n    setValue,\n    {\n      isControlled,\n      reset,\n    },\n  ];\n}\n"
    }
  ],
  "category": "lib"
}