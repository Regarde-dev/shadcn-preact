{
  "name": "useArrowKeyNavigation",
  "type": "registry:lib",
  "description": "Hook for arrow key navigation",
  "files": [
    {
      "path": "share/useArrowKeyNavigation.tsx",
      "type": "registry:lib",
      "content": "import { type RefObject, useEffect, useState } from \"preact/compat\";\n\nexport interface UseArrowKeyNavigationOptions {\n  enabled?: boolean;\n  selector?: string;\n  orientation?: \"vertical\" | \"horizontal\" | \"both\";\n  loop?: boolean;\n  onSelect?: (index: number, element: HTMLElement) => void;\n}\n\n/**\n * Hook to handle arrow key navigation within a container\n * @param containerRef - Ref to the container element\n * @param options - Configuration options\n * @returns Object containing focusedIndex state\n */\nexport function useArrowKeyNavigation(\n  containerRef: RefObject<HTMLElement>,\n  options: UseArrowKeyNavigationOptions = {}\n) {\n  const {\n    enabled = true,\n    selector = '[role=\"option\"]:not([data-disabled=\"true\"])',\n    orientation = \"vertical\",\n    loop = true,\n    onSelect,\n  } = options;\n\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n\n  useEffect(() => {\n    if (!enabled || !containerRef.current) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const items = Array.from(containerRef.current?.querySelectorAll<HTMLElement>(selector) || []);\n\n      if (items.length === 0) return;\n\n      const isVertical = orientation === \"vertical\" || orientation === \"both\";\n      const isHorizontal = orientation === \"horizontal\" || orientation === \"both\";\n\n      switch (e.key) {\n        case \"ArrowDown\":\n          if (!isVertical) return;\n          e.preventDefault();\n          setFocusedIndex((prev) => {\n            const next = prev === -1 ? 0 : loop ? (prev + 1) % items.length : Math.min(prev + 1, items.length - 1);\n            items[next]?.focus();\n            return next;\n          });\n          break;\n\n        case \"ArrowUp\":\n          if (!isVertical) return;\n          e.preventDefault();\n          setFocusedIndex((prev) => {\n            const next =\n              prev === -1 ? items.length - 1 : loop ? (prev - 1 + items.length) % items.length : Math.max(prev - 1, 0);\n            items[next]?.focus();\n            return next;\n          });\n          break;\n\n        case \"ArrowRight\":\n          if (!isHorizontal) return;\n          e.preventDefault();\n          setFocusedIndex((prev) => {\n            const next = prev === -1 ? 0 : loop ? (prev + 1) % items.length : Math.min(prev + 1, items.length - 1);\n            items[next]?.focus();\n            return next;\n          });\n          break;\n\n        case \"ArrowLeft\":\n          if (!isHorizontal) return;\n          e.preventDefault();\n          setFocusedIndex((prev) => {\n            const next =\n              prev === -1 ? items.length - 1 : loop ? (prev - 1 + items.length) % items.length : Math.max(prev - 1, 0);\n            items[next]?.focus();\n            return next;\n          });\n          break;\n\n        case \"Home\":\n          e.preventDefault();\n          setFocusedIndex(0);\n          items[0]?.focus();\n          break;\n\n        case \"End\":\n          e.preventDefault();\n          setFocusedIndex(items.length - 1);\n          items[items.length - 1]?.focus();\n          break;\n\n        case \"Enter\":\n        case \" \":\n          e.preventDefault();\n          if (focusedIndex >= 0 && focusedIndex < items.length && items[focusedIndex]) {\n            onSelect?.(focusedIndex, items[focusedIndex]);\n          }\n          break;\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [enabled, containerRef, selector, orientation, loop, focusedIndex, onSelect]);\n\n  return { focusedIndex, setFocusedIndex };\n}\n"
    }
  ],
  "category": "lib"
}