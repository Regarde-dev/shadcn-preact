{
  "name": "compose_ref",
  "type": "registry:lib",
  "description": "Utility for composing multiple refs",
  "files": [
    {
      "path": "share/compose_ref.tsx",
      "type": "registry:lib",
      "content": "/**\n * This funtionality is used to compose multiple refs together\n * It allows you to pass multiple refs to a single component\n * and have them all receive the same value.\n *\n * All credit goes to the original author of this code:\n * Radix UI\n */\n\nimport type { RefCallback } from \"preact\";\nimport { useCallback } from \"preact/hooks\";\n\ntype PossibleRef<T> = React.Ref<T | null> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): RefCallback<T> {\n  // @ts-expect-error\n  return (node) => {\n    let hasCleanup = false;\n\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    return cleanups;\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): RefCallback<T> {\n  return useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n"
    }
  ],
  "category": "lib"
}