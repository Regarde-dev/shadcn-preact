{
  "name": "select",
  "type": "registry:ui",
  "description": "Displays a list of options for the user to pick fromâ€”triggered by a button.",
  "dependencies": [
    "lucide-preact"
  ],
  "registryDependencies": [
    "cn",
    "slot",
    "portal",
    "compose_ref",
    "useControlledState",
    "useEscapeKeyDown",
    "useClickOutside",
    "useArrowKeyNavigation",
    "useId"
  ],
  "files": [
    {
      "path": "select.tsx",
      "type": "registry:ui",
      "content": "import { autoUpdate, flip, offset, shift, useFloating, type Placement } from \"@floating-ui/react-dom\";\nimport { Check, ChevronDown } from \"lucide-preact\";\nimport type { ButtonHTMLAttributes, CSSProperties, HTMLAttributes } from \"preact\";\nimport {\n  createContext,\n  forwardRef,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type PropsWithChildren,\n} from \"preact/compat\";\nimport { Portal } from \"./portal\";\nimport { cn } from \"./share/cn\";\nimport { useComposedRefs } from \"./share/compose_ref\";\nimport { Slot } from \"./share/slot\";\nimport { useArrowKeyNavigation } from \"./share/useArrowKeyNavigation\";\nimport { useClickOutside } from \"./share/useClickOutside\";\nimport { useControlledState } from \"./share/useControlledState\";\nimport { useEscapeKeyDown } from \"./share/useEscapeKeyDown\";\n\n// Select Context\nexport type SelectSide = \"top\" | \"right\" | \"bottom\" | \"left\";\nexport type SelectAlign = \"start\" | \"center\" | \"end\";\n\ntype SelectContextValue = {\n  open: boolean;\n  setOpen: (open: boolean) => void;\n  value: string;\n  onValueChange: (value: string) => void;\n  selectedLabel: string;\n  setSelectedLabel: (label: string) => void;\n  disabled?: boolean;\n  refs: {\n    reference: { current: HTMLElement | null };\n    floating: { current: HTMLElement | null };\n    setReference: (node: HTMLElement | null) => void;\n    setFloating: (node: HTMLElement | null) => void;\n  };\n  floatingStyles: CSSProperties;\n  maxHeight?: number;\n};\n\nconst SelectContext = createContext<SelectContextValue | null>(null);\n\nexport type SelectProps = PropsWithChildren & {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  disabled?: boolean;\n  name?: string;\n  required?: boolean;\n  side?: SelectSide;\n  sideOffset?: number;\n  align?: SelectAlign;\n  alignOffset?: number;\n};\n\nexport const Select = ({\n  children,\n  open: controlledOpen,\n  defaultOpen = false,\n  onOpenChange,\n  value: controlledValue,\n  defaultValue = \"\",\n  onValueChange,\n  disabled,\n  name,\n  required,\n  side = \"bottom\",\n  sideOffset = 4,\n  align = \"start\",\n  alignOffset = 0,\n}: SelectProps) => {\n  const [selectedLabel, setSelectedLabel] = useState(\"\");\n\n  const [open, setOpen] = useControlledState({\n    defaultValue: defaultOpen,\n    controlledValue: controlledOpen,\n    onChange: onOpenChange,\n  });\n\n  const [value, setValue] = useControlledState({\n    defaultValue: defaultValue,\n    controlledValue: controlledValue,\n    onChange: onValueChange,\n  });\n\n  const placement = useMemo((): Placement => {\n    if (align === \"center\" || align === \"start\") {\n      if (side === \"bottom\" || side === \"top\") {\n        return align === \"start\" ? `${side}-start` : side;\n      }\n      return align === \"start\" ? `${side}-start` : side;\n    }\n    return `${side}-end` as Placement;\n  }, [side, align]);\n\n  const fallbackPlacements = useMemo((): Placement[] => {\n    const fallbacks: Placement[] = [];\n\n    if (side === \"bottom\" || side === \"top\") {\n      const oppositeSide = side === \"bottom\" ? \"top\" : \"bottom\";\n      if (align === \"start\") {\n        fallbacks.push(`${oppositeSide}-start`);\n      } else if (align === \"end\") {\n        fallbacks.push(`${oppositeSide}-end`);\n      } else {\n        fallbacks.push(oppositeSide);\n      }\n    } else {\n      const oppositeSide = side === \"left\" ? \"right\" : \"left\";\n      if (align === \"start\") {\n        fallbacks.push(`${oppositeSide}-start`);\n      } else if (align === \"end\") {\n        fallbacks.push(`${oppositeSide}-end`);\n      } else {\n        fallbacks.push(oppositeSide);\n      }\n    }\n\n    return fallbacks;\n  }, [side, align]);\n\n  const {\n    refs,\n    floatingStyles,\n    placement: currentPlacement,\n  } = useFloating<HTMLElement>({\n    open: open,\n    strategy: \"fixed\",\n    placement: placement,\n    middleware: [\n      offset(sideOffset + alignOffset),\n      flip({\n        fallbackPlacements: fallbackPlacements,\n      }),\n      shift(),\n    ],\n    whileElementsMounted: autoUpdate,\n    transform: false,\n  });\n\n  const [maxHeight, setMaxHeight] = useState<number | undefined>();\n\n  // Calculate dynamic max-height based on available viewport space\n  useEffect(() => {\n    if (!open || !refs.floating.current || !refs.reference.current) {\n      setMaxHeight(undefined);\n      return;\n    }\n\n    const calculateMaxHeight = () => {\n      const referenceRect = refs.reference.current!.getBoundingClientRect();\n      const viewportHeight = window.innerHeight;\n      const viewportPadding = 8;\n\n      const actualPlacement = currentPlacement || placement;\n      const isVertical = actualPlacement.startsWith(\"top\") || actualPlacement.startsWith(\"bottom\");\n\n      let availableSpace: number;\n\n      if (isVertical) {\n        if (actualPlacement.startsWith(\"bottom\")) {\n          availableSpace = viewportHeight - referenceRect.bottom - viewportPadding - sideOffset;\n        } else {\n          availableSpace = referenceRect.top - viewportPadding - sideOffset;\n        }\n      } else {\n        const spaceAbove = referenceRect.top - viewportPadding;\n        const spaceBelow = viewportHeight - referenceRect.bottom - viewportPadding;\n        availableSpace = Math.max(spaceAbove, spaceBelow, viewportHeight - viewportPadding * 2);\n      }\n\n      const cappedHeight = Math.max(100, Math.min(availableSpace, 384));\n      setMaxHeight(cappedHeight);\n    };\n\n    calculateMaxHeight();\n  }, [open, refs, currentPlacement, placement, sideOffset]);\n\n  return (\n    <SelectContext.Provider\n      value={{\n        open,\n        setOpen,\n        value,\n        onValueChange: setValue,\n        selectedLabel,\n        setSelectedLabel,\n        disabled,\n        refs,\n        floatingStyles,\n        maxHeight,\n      }}\n    >\n      {children}\n      {/* Hidden native select for form integration */}\n      {name && (\n        <select\n          name={name}\n          disabled={disabled}\n          required={required}\n          defaultValue={defaultValue}\n          tabIndex={-1}\n          value={value}\n          onChange={(e) => setValue((e.target as HTMLSelectElement).value)}\n          className=\"-top-[99999px] pointer-events-none fixed h-1 w-1 cursor-none\"\n          aria-hidden=\"true\"\n        >\n          <option value={value}>{value}</option>\n        </select>\n      )}\n    </SelectContext.Provider>\n  );\n};\n\nfunction useSelect() {\n  const context = useContext(SelectContext);\n  if (!context) {\n    throw new Error(\"Select components must be used within a Select component\");\n  }\n  return context;\n}\n\n// SelectTrigger\nexport type SelectTriggerProps = PropsWithChildren &\n  ButtonHTMLAttributes<HTMLButtonElement> & {\n    asChild?: boolean;\n  };\n\nexport const SelectTrigger = forwardRef<HTMLButtonElement, SelectTriggerProps>(\n  ({ children, className, class: classNative, asChild = false, onClick, onKeyDown, ...props }, forwardedRef) => {\n    const { open, setOpen, disabled, value, refs } = useSelect();\n    const triggerRef = useRef<HTMLElement>(null);\n\n    const composedRefs = useComposedRefs(triggerRef as any, forwardedRef as any, (node: HTMLElement | null) =>\n      refs.setReference(node)\n    );\n\n    const handleClick: typeof onClick = (e) => {\n      if (disabled) return;\n      setOpen(!open);\n      if (onClick) onClick(e);\n    };\n\n    const handleKeyDown: typeof onKeyDown = (e) => {\n      if (disabled) return;\n      if (e.key === \" \" || e.key === \"Enter\") {\n        e.preventDefault();\n        setOpen(true);\n      }\n      if (onKeyDown) onKeyDown(e);\n    };\n\n    const Comp = asChild ? Slot : \"button\";\n\n    return (\n      <Comp\n        ref={composedRefs}\n        type={asChild ? undefined : \"button\"}\n        onClick={handleClick}\n        onKeyDown={handleKeyDown}\n        disabled={disabled}\n        role=\"button\"\n        aria-expanded={open}\n        aria-controls=\"select-content\"\n        data-slot=\"select-trigger\"\n        data-state={open ? \"open\" : \"closed\"}\n        data-disabled={disabled ? \"true\" : undefined}\n        data-placeholder={!value ? \"\" : undefined}\n        className={cn(\n          \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n          className,\n          classNative\n        )}\n        {...props}\n      >\n        {children}\n        <ChevronDown className=\"h-4 w-4 opacity-50\" />\n      </Comp>\n    );\n  }\n);\nSelectTrigger.displayName = \"SelectTrigger\";\n\n// SelectValue\nexport type SelectValueProps = HTMLAttributes<HTMLSpanElement> & {\n  placeholder?: string;\n};\n\nexport const SelectValue = forwardRef<HTMLSpanElement, SelectValueProps>(\n  ({ className, class: classNative, placeholder, ...props }, forwardedRef) => {\n    const { value, selectedLabel } = useSelect();\n\n    return (\n      <span\n        ref={forwardedRef}\n        data-slot=\"select-value\"\n        className={cn(className, classNative)}\n        {...props}\n      >\n        {value ? selectedLabel || value : <span className=\"text-muted-foreground\">{placeholder}</span>}\n      </span>\n    );\n  }\n);\nSelectValue.displayName = \"SelectValue\";\n\n// SelectContent\nexport type SelectContentProps = HTMLAttributes<HTMLDivElement>;\n\nexport const SelectContent = forwardRef<HTMLDivElement, SelectContentProps>(\n  ({ className, class: classNative, children, ...props }, forwardedRef) => {\n    const { open, setOpen, value, refs, floatingStyles, maxHeight } = useSelect();\n    const contentRef = useRef<HTMLDivElement>(null);\n\n    const composedRefs = useComposedRefs(contentRef, forwardedRef as any, (node: HTMLDivElement | null) =>\n      refs.setFloating(node)\n    );\n\n    const [triggerWidth, setTriggerWidth] = useState(0);\n    useEffect(() => {\n      if (open && refs.reference.current) {\n        setTriggerWidth(refs.reference.current.getBoundingClientRect().width);\n      }\n    }, [open, refs.reference]);\n\n    // Auto-focus selected item or first item when opened\n    useEffect(() => {\n      if (!open || !refs.floating.current) return;\n\n      const timer = setTimeout(() => {\n        if (!refs.floating.current) return;\n\n        const items = Array.from(\n          refs.floating.current.querySelectorAll<HTMLElement>('[role=\"option\"]:not([data-disabled=\"true\"])')\n        );\n\n        if (items.length === 0) return;\n\n        // Focus the selected item first\n        if (value) {\n          const selectedIndex = items.findIndex((item) => item.getAttribute(\"data-state\") === \"checked\");\n          if (selectedIndex !== -1 && items[selectedIndex]) {\n            items[selectedIndex].focus();\n            return;\n          }\n        }\n\n        // Otherwise focus the first non-disabled item\n        if (items[0]) {\n          items[0].focus();\n        }\n      }, 0);\n\n      return () => clearTimeout(timer);\n    }, [open, value, refs.floating]);\n\n    // Handle escape key with focus restoration\n    useEscapeKeyDown(() => setOpen(false), {\n      enabled: open,\n      restoreFocus: refs.reference as any,\n    });\n\n    // Handle click outside\n    useClickOutside([contentRef, refs.reference as any], () => setOpen(false), {\n      enabled: open,\n    });\n\n    // Handle arrow key navigation\n    useArrowKeyNavigation(refs.floating as any, {\n      enabled: open,\n      onSelect: (_index, element) => element.click(),\n    });\n\n    if (!open) return null;\n\n    return (\n      <Portal>\n        <div\n          ref={composedRefs}\n          id=\"select-content\"\n          role=\"listbox\"\n          data-slot=\"select-content\"\n          data-state=\"open\"\n          style={{\n            ...floatingStyles,\n            minWidth: `${triggerWidth}px`,\n            maxHeight: maxHeight ? `${maxHeight}px` : undefined,\n          }}\n          className={cn(\n            \"z-50 min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md\",\n            \"fade-in-0 zoom-in-95 animate-in\",\n            \"data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n            className,\n            classNative\n          )}\n          {...props}\n        >\n          {children}\n        </div>\n      </Portal>\n    );\n  }\n);\nSelectContent.displayName = \"SelectContent\";\n\n// SelectGroup\nexport type SelectGroupProps = HTMLAttributes<HTMLDivElement>;\n\nexport const SelectGroup = forwardRef<HTMLDivElement, SelectGroupProps>(\n  ({ className, class: classNative, ...props }, forwardedRef) => (\n    <div\n      ref={forwardedRef}\n      data-slot=\"select-group\"\n      role=\"group\"\n      className={cn(\"p-1\", className, classNative)}\n      {...props}\n    />\n  )\n);\nSelectGroup.displayName = \"SelectGroup\";\n\n// SelectLabel\nexport type SelectLabelProps = HTMLAttributes<HTMLDivElement>;\n\nexport const SelectLabel = forwardRef<HTMLDivElement, SelectLabelProps>(\n  ({ className, class: classNative, ...props }, forwardedRef) => (\n    <div\n      ref={forwardedRef}\n      data-slot=\"select-label\"\n      className={cn(\"py-1.5 pr-2 pl-8 font-semibold text-sm\", className, classNative)}\n      {...props}\n    />\n  )\n);\nSelectLabel.displayName = \"SelectLabel\";\n\n// SelectItem\nexport type SelectItemProps = HTMLAttributes<HTMLDivElement> & {\n  value: string;\n  disabled?: boolean;\n};\n\nexport const SelectItem = forwardRef<HTMLDivElement, SelectItemProps>(\n  ({ className, class: classNative, value: itemValue, disabled, children, onClick, ...props }, forwardedRef) => {\n    const { value, onValueChange, setOpen, setSelectedLabel } = useSelect();\n    const itemRef = useRef<HTMLDivElement>(null);\n    const [isFocused, setIsFocused] = useState(false);\n    const isSelected = value === itemValue;\n\n    const composedRefs = useComposedRefs(itemRef, forwardedRef as any);\n\n    const handleClick: typeof onClick = (e) => {\n      if (disabled) return;\n      onValueChange(itemValue);\n      const label = typeof children === \"string\" ? children : itemRef.current?.textContent || itemValue;\n      setSelectedLabel(label);\n      setOpen(false);\n      if (onClick) onClick(e);\n    };\n\n    const handleMouseEnter = () => {\n      if (disabled) return;\n      itemRef.current?.focus();\n      setIsFocused(true);\n    };\n\n    const handleMouseLeave = () => {\n      setIsFocused(false);\n    };\n\n    const handleFocus = () => {\n      if (disabled) return;\n      setIsFocused(true);\n    };\n\n    const handleBlur = () => {\n      setIsFocused(false);\n    };\n\n    return (\n      <div\n        ref={composedRefs}\n        data-slot=\"select-item\"\n        data-disabled={disabled ? \"true\" : undefined}\n        data-state={isSelected ? \"checked\" : \"unchecked\"}\n        role=\"option\"\n        aria-selected={isSelected}\n        tabIndex={disabled ? -1 : 0}\n        className={cn(\n          \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none\",\n          \"data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50\",\n          isFocused && \"bg-accent text-accent-foreground\",\n          className,\n          classNative\n        )}\n        onClick={handleClick}\n        onMouseEnter={handleMouseEnter}\n        onMouseLeave={handleMouseLeave}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        {...props}\n      >\n        <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n          {isSelected && <Check className=\"h-4 w-4\" />}\n        </span>\n        {children}\n      </div>\n    );\n  }\n);\nSelectItem.displayName = \"SelectItem\";\n\n// SelectSeparator\nexport type SelectSeparatorProps = HTMLAttributes<HTMLDivElement>;\n\nexport const SelectSeparator = forwardRef<HTMLDivElement, SelectSeparatorProps>(\n  ({ className, class: classNative, ...props }, forwardedRef) => (\n    <div\n      ref={forwardedRef}\n      data-slot=\"select-separator\"\n      className={cn(\"-mx-1 my-1 h-px bg-muted\", className, classNative)}\n      {...props}\n    />\n  )\n);\nSelectSeparator.displayName = \"SelectSeparator\";\n\n// TODO: SelectScrollUpButton and SelectScrollDownButton\n"
    }
  ],
  "category": "ui"
}